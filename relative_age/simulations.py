"""
Implements simulations with or without error.
"""

import numpy as np
import math
import msprime
import tsinfer
import logging
import warnings
import pandas as pd
from ast import literal_eval as make_tuple
warnings.filterwarnings("ignore",message="numpy.dtype size changed")

import geva_compare
import freq_compare



def msprime_simulation(name,sample_size, Ne, length, recombination_rate, mutation_rate):
    #Step one: simulate dataset with msprime
    simulation = msprime.simulate(sample_size=sample_size, Ne=Ne, length=length, recombination_rate=recombination_rate, mutation_rate=mutation_rate)
    with open("../tmp/"+name+".vcf", "w") as vcf_file:
        simulation.write_vcf(vcf_file, 2)
    return(simulation)

def make_errors(g, p):
    """
    Resample for a specific variant, whose genotypes g are passed in
    For each sample an error occurs with probability p. Errors are generated by
    sampling values from the stationary distribution, that is, if we have an
    allele frequency of f, a 1 is emitted with probability f and a
    0 with probability 1 - f. Thus, there is a possibility that an 'error'
    will in fact result in the same value.
    """
    w = np.copy(g)
    if p > 0:
        m = g.shape[0]
        frequency = np.sum(g) / m
        # Randomly choose samples with probability p
        samples = np.where(np.random.random(m) < p)[0]
        # Generate observations from the stationary distribution.
        errors = (np.random.random(samples.shape[0]) < frequency).astype(int)
        w[samples] = errors
    return w

def make_errors_genotype_model(g, error_matrix):
    """
    Given an empirically estimated error matrix, resample for a particular
    variant. Given a true genotype of g0, g1, or g2, return observed genotype
    depending on the error_matrix. For example, given a variant with genotype
    g0, return g0 with probability 99.942%, g1 with probability 0.041%, and
    g2 with probability 0.017%. Treat each pair of alleles as a diploid 
    individual. 
    """
    w = np.copy(g)
    #Make diploid (iterate each pair of alleles)
    genos=[(w[i],w[i+1]) for i in range(0,w.shape[0],2)]
    #Record the true genotypes
    g0 = [i for i, x in enumerate(genos) if x == (0,0)]
    g1a = [i for i, x in enumerate(genos) if x == (1,0)]
    g1b = [i for i, x in enumerate(genos) if x == (0,1)]
    g2 = [i for i, x in enumerate(genos) if x == (1,1)]
    

    for idx in g0:
        result=make_tuple(np.random.choice(['(0,0)','(1,0)','(1,1)'], p=error_matrix.as_matrix(['p00','p01','p02'])[0]))
        if result == 1:
            genos[idx]=make_tuple(np.random.choice(['(0,0)','(1,0)'], 1)[0])
        else:
            genos[idx] = result

    for idx in g1a:
        genos[idx]=make_tuple(np.random.choice(['(0,0)','(1,0)','(1,1)'], p=error_matrix.as_matrix(['p10','p11','p12'])[0]))

    for idx in g1b:
        genos[idx]=make_tuple(np.random.choice(['(0,0)','(0,1)','(1,1)'], p=error_matrix.as_matrix(['p10','p11','p12'])[0]))

    for idx in g2:
        result=make_tuple(np.random.choice(['(0,0)','(1,0)','(1,1)'], p=error_matrix.as_matrix(['p20','p21','p22'])[0]))
        if result == 1:
            genos[idx]=make_tuple(np.random.choice(['(0,0)','(1,0)'], 1)[0])
        else:
            genos[idx] = result
    return(np.array(sum(genos, ())))
    

def generate_samples(ts, filename, real_error_rate=0):
    """
    Generate a samples file from a simulated ts
    Samples may have bits flipped with a specified probability.
    (reject any variants that result in a fixed column)
    """
   
    if real_error_rate > 0:
        logging.debug("converting real error rate to an error param by multiplying by log(n)")
    error_param = real_error_rate * math.log(ts.num_samples)
    record_rate = logging.getLogger().isEnabledFor(logging.INFO)
    n_variants = bits_flipped = 0
    assert ts.num_sites != 0
    sample_data = tsinfer.SampleData(path="../data/"+filename + "/"+filename+".samples", sequence_length=ts.sequence_length)
    for v in ts.variants():
        n_variants += 1
        if error_param <=0:
            sample_data.add_site(
                position=v.site.position, alleles=v.alleles,
                genotypes=v.genotypes)
        else:
            #make new genotypes with error
            # Reject any columns that have no 1s or no zeros.
            # Unless the original also has them, as occasionally we have
            # some sims (e.g. under selection) where a variant is fixed
            while True:
                genotypes = make_errors(v.genotypes, error_param)
                s = np.sum(genotypes)
                if 0 < s < ts.sample_size:
                    break
                if s == np.sum(v.genotypes):
                    break
            if record_rate:
                bits_flipped += np.sum(np.logical_xor(genotypes, v.genotypes))
            sample_data.add_site(
                position=v.site.position, alleles=v.alleles,
                genotypes=genotypes)
    if real_error_rate>0:
        logging.info("Error of {} injected into {}".format(real_error_rate, os.path.basename(filename))
            + ": actual error rate = {} (error param = {})".format(
                bits_flipped/(n_variants*ts.sample_size), error_param) if record_rate else "")
    sample_data.finalise()
    return sample_data

def generate_samples_genotype(ts, filename):
    """
    Generate a samples file from a simulated ts
    (reject any variants that result in a fixed column)
    """
    error_matrix=pd.read_csv("/home/wilderwohns/relative_allele_age/data/result.profile.1000g.platinum.empirical.csv")
    record_rate = logging.getLogger().isEnabledFor(logging.INFO)
    n_variants = bits_flipped = 0
    assert ts.num_sites != 0
    sample_data = tsinfer.SampleData(path="../data/"+filename + "/"+filename+".samples", sequence_length=ts.sequence_length)
    for v in ts.variants():
        n_variants += 1


        #Record the allele frequency
        m = v.genotypes.shape[0]
        frequency = np.sum(v.genotypes) / m
        #Find closest row in error matrix file
        closest_freq = error_matrix.iloc[(error_matrix['freq']-frequency).abs().argsort()[:1]]
       
        #make new genotypes with error
        # Reject any columns that have no 1s or no zeros.
        # Unless the original also has them, as occasionally we have
        # some sims (e.g. under selection) where a variant is fixed
        while True:
            genotypes = make_errors_genotype_model(v.genotypes,closest_freq)
            s = np.sum(genotypes)
            if 0 < s < ts.sample_size:
                break
            if s == np.sum(v.genotypes):
                break
        if record_rate:
            bits_flipped += np.sum(np.logical_xor(genotypes, v.genotypes))
        sample_data.add_site(
            position=v.site.position, alleles=v.alleles,
            genotypes=genotypes)
  
    logging.info(": actual error rate = {}".format(
            bits_flipped/(n_variants*ts.sample_size)) if record_rate else "")
    sample_data.finalise()
    return sample_data

